---
title: Nginx后端服务器组配置的5个指令
tags:
  - nginx
categories:
  - 后端开发
toc: false
date: 2017-09-02 08:20:49
---

Nginx服务器支持设置一组服务器作为后端服务器。

服务器组的设置包括几个指令，他们是由标准HTTP模块ngx_http_upstream_module进行解析和处理的，我们在这里分别介绍一下。

<!-- more -->

### upstream 指令

该指令是设置后端服务器组的主要指令，其他的指令都在该指令中进行设置。其语法结构为：

```
upstream name {
  ...
}
```

其中，name是给后端服务器组起得组名。花括号中列出后端服务器组中包含的服务器，其中可以使用下面是介绍的其他指令。

默认情况下，某个服务器组接收到请求以后，按照轮叫调度（Round-Robin，RR）策略顺序选择组内服务器处理请求。如果一个服务器在处理请求的过程中出现错误，请求会被顺次交给组内的下一个服务器进行处理，以此类推，知道返回正常响应。如果所有的组内服务器都出错，则返回最后一个服务器的处理结果。当然我们可以根据各个服务器处理能力或者资源配置情况的不同，给各个服务器配置不同的权重，让能力强的服务器多处理请求，能力弱的少处理。配置权重的变量包含在server指令中。

### server 指令

该指令用于这只组内的服务器，其语法结构为：

 ```
 server address [parameters];
 ```

 > address，服务器的地址，可以是包含端口号的IP地址（IP:Port）、域名或者以『unix:』为前缀用于进程间通信的Unix Domain Socket。

 > parameters，为当前服务器配置更多属性。这些属性变量包含以下内容：

 >> weight=number，为组内服务器设置权重，权重值高的服务器被优先用于处理请求。此时组内服务器的选择策略为加权轮叫策略。组内所有服务器的权重默认设置为1，即采用一般轮叫调度原则处理请求。

 >> max_fails=number，设置一个请求失败的次数。在一定事件范围内，当对组内某台服务器请求失败的次数超过该变量设置的值时，认为该服务器无效（down）。请求失败的各种情况与proxy_next_upstream指令（在学习Nginx服务器的缓存机制时，是fastcgi_next_upstream指令或者memcached_next_upstream指令）的配置相匹配。默认设置为1。如果设置为0，则不适用上面的办法检查服务器是否有效

 >> 注意：HTTP 404 状态不被认为是请求失败

 >> fail_timeout=time，有两个作用，一时设置max_fails指令尝试请求某台组内服务器的时间，即学习max_fails指令时提到的"一定时间范围内"；另一个作用是在检查服务器是否有效时，如果一台服务器被认为是无效（down）的，该变量设置的时间为认为服务器无效的持续时间。在这个时间内不再检查该服务器的状态，并一直认为它是无效（down）的。默认设置为10s。

 >> backup，将某台组内服务器标记为备用服务器，只有当正常的服务器处于无效（down）状态或者繁忙（busy）状态时，该服务器才被用来处理客户端请求。

 >> down，将某台组内服务器标记为永久的无效状态，通常与ip_hash指令配合使用。该指令在Nginx 0.6.7 及以上版本中提供。

 我们来通过实例深入对server指令配置的理解：

```
upstream backend {
  server backend1.example.com weight=5;
  server 127.0.0.1:8080 max_fails=3 fail_timeout=30s;
  server unix:/tmp/backend3;
}
```

在该实例中，我们设置了一个名叫backend的服务器组，组内包含三台服务器，分别是基于域名的backend1.example.com、基于IP地址的127.0.0.1:8080和用于进程间通信的Unix Domain Socket。backend1.example.com的权重设置为5，为组内最大，优先接受和处理请求；对本地服务器127.0.0.1:8080的检查设置是，如果30s内连续产生3次请求失败，则改服务器在之后的30s内被认为是无效（down）状态。  

### ip_hash 指令

该指令用于实现会话保持功能，将某个客户端的多次请求定向到组内同一台服务器上，保证客户端与服务器之间建立稳定的会话。只有当该服务器处于无效（down）状态时，客户端请求才会被下一个服务器接收和处理。其语法结构为：
```
ip_hash;
```

ip_hash技术在一些情况下非常有用，能够避免我们关心的服务器组内个服务器之间会话共享的问题。但是ip_hash技术再实际使用过程中也有限制。

首先，ip_hash指令不能与server指令中的weight变量一起使用。其次，由于ip_hash技术主要根据客户端IP地址分配服务器，因此在整个系统中，Nginx服务器应该是处于最前端的服务器，这样才能够获取到客户端的IP地址，否则他得到的IP地址将是位于它前面的服务器地址，从而就会产生问题。同事要注意，客户端IP地址必须是C类地址。Nginx 1.3.2开发版本和Nginx 1.2.2稳定版本开始支持IPv6地址。

我们来看下面这个实例：

```
upstream backend {
  ip_hash;
  server myback1.proxy.com;
  server myback2.proxy.com;
}
```

该实例中配置了一个名叫backend的服务器组，包含两台后端服务器myback1.proxy.com和myback2.proxy.com。在添加ip_hash指令后，我们使用同一个客户端向Nginx服务器发送请求，将会看到一只是有服务器myback1.proxy.com响应；如果注释掉ip_hash指令后进行相同的操作，发现组内的两台服务器轮流响应请求。

### keepalive 指令

该指令用于控制网络连接保持功能。通过该指令，能够保证Nginx服务器的工作进程为服务区组打开一部分网络连接，并且将数量控制在一定的范围之内。其语法结构为：
```
keepalive connections;
```

其中，connections为 Nginx 服务器的每个工作进程允许该服务器组保持的空闲网络连接数的上限值。如果超过该值，工作进程将采用最近最少使用的策略关闭网络连接。

该指令从Nginx 1.1.4开始被支持。

> 注意：该指令不能限制Nginx服务器工作进程能够为服务器组开启的总网络连接数。connections变量在设置时也不要设置得太大，否则会影响服务器组与新网络连接的建立。

### least_conn 指令

该指令用于配置Nginx服务器使用负载均衡策略为网络连接分配服务器组内的服务器。该指令在功能上实现了最少连接负载均衡算法，在选择组内的服务器时，考虑各服务器权重的同时，每次选择的都是当前网络连接最少的那台服务器，如果这样的服务器有多台，就采用加权轮叫原则选择权重最大的服务器。其语法结构为：
```
least_conn;
```
